<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Start a membership service with Firebase</title>

<style>
body {
;	max-width			: 640px
}
pre {
;	background-color	: black
;	padding				: 12px
;	overflow			: scroll
;	tab-size			: 4
}
code {
;	color				: blue
}
pre > code {
;	color				: yellow
}
img {
;	max-width			: 320px
}
</style>
</head>

<body>



<h2>Start a membership online service with Firebase</h2>


<p>In recent years, the development of cloud services has created an environment where individuals can easily start their own membership-based online services.</p>

<p>In particular, using a Backend as a Service (BaaS) like Firebase allows developers to greatly simplify the complex process of building a backend. </p>

<p>Firebase provides many of the features needed to build an online service, such as authentication, database, file storage, and serverless functions, allowing developers to focus on the core functionality of their service.</p>

<p>Firebase also automatically scales with service growth, which can significantly reduce operational costs.</p>

<p>In this article, I will explain the specific steps for starting a membership-based online service as an individual using Firebase, while creating a fictitious service with slightly relaxed security as an example.</p>

<hr>

<h3>Fictitious service specification</h3>

<img src=HOME.png alt="Home image">

<h4>Concept:</h4>
<ul>
<li>Type: Investment information portal</li>
<li>Revenue model: Advertising revenue and newsletter subscriptions</li>
</ul>

<h4>Functional requirements:</h4>
<ul>
	<li>User registration and login</li>
	<li>Content management</li>
	<li>Payment processing</li>
	<li>External API integration:
		<ul>
			<li>Various market data APIs</li>
			<li>Scraping</li>
		</ul>
	</li>
	<li>Single-page application (SPA)</li>
</ul>

<h4>Security requirements:</h4>
<ul>
	<li>Only email addresses stored</li>
	<li>No personal information collected</li>
</ul>

<h4>Technical requirements:</h4>
<ul>
	<li>Frontend: Vanilla JS</li>
	<li>Backend: Firebase</li>
	<li>Database: Firebase Firestore</li>
	<li>Authentication: Firebase Authentication</li>
	<li>Payment processing: Stripe</li>
	<li>External APIs:
		<ul>
			<li>Cryptocurrency exchanges</li>
			<li>Precios metals dealers</li>
		</ul>
	</li>
</ul>

<p>The source code is available on <a href=https://github.com/Satachito/exp-fb target=_blank>GitHub</a> and service is available at <a href=https://exp-fb-c223c.web.app/ target=_blank>https://exp-fb-c223c.web.app/</a>.

<hr>

<h3>Table of contents:</h3>
<ul>
	<li><a href=#AUTH		>Firebase Authentication</a></li>
	<li><a href=#STORE		>Firebase Firestore		</a></li>
	<li><a href=#FUNC		>Firebase Functions		</a></li>
	<li><a href=#SPA_ROUTER	>SPA and Router			</a>
		<ul>
			<li><a href=#SPA>SPA</a></li>
			<li><a href=#ROUTER>ROUTER</a></li>
		</ul>
	</li>
</ul>

<hr>
<h2 id="AUTH">Firebase Authentication</h2>
<p>Firebase is a powerful platform that facilitates app development. However, it's currently undergoing frequent updates, notably transitioning to v9, which introduces the Modular API. This new API significantly alters the syntax from the traditional one.</p>
<h4>Migrating to the Modular API</h4>
<p>While the Modular API offers enhanced flexibility and efficiency, it breaks compatibility with legacy code. Although compat versions are provided by the Firebase team, migrating to the Modular API is recommended for future-proofing your projects.</p>
<h4>Firebase-UI and the Modular API</h4>
<p>Firebase includes Firebase-UI, a handy UI library for implementing features like login. However, Firebase-UI doesn't support the Modular API yet, necessitating a potentially time-consuming migration process.</p>
<h4>Adapting to Future Changes</h4>
<p>Given Firebase's ongoing evolution, anticipate further significant changes in the future.</p>
<h4>Implementing a Secure Login Solution</h4>
<p>Considering this evolving landscape, directly utilizing Firebase's features to implement login functionality emerges as the most sustainable approach.</p>
<img src="SS1.png" alt="Login dialog image">
<img src="SS2.png" alt="Login dialog image">
<img src="SS3.png" alt="Login dialog image">
<img src="SS4.png" alt="Login dialog image">
<p>By embracing the latest Firebase developments and implementing login functionality directly, developers can ensure their applications' longevity and adaptability.</p>
<p>For the code, HTML and CSS are provided on CodePen. JavaScript follows separately since Firebase doesn't function within CodePen. You can view a working version <a href="https://tech.sat.tokyo/Contents/FirebaseAuth.html" target="_blank">here</a>.</p>
<p class="codepen" data-height="300" data-default-tab="html" data-slug-hash="RwOyxzr" data-user="satachito" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/satachito/pen/RwOyxzr">
  Firebase AUTH</a> by Satachito (<a href="https://codepen.io/satachito">@satachito</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<p>If a user creates an account using <code>createUserWithEmailAndPassword</code>, <code>signInWithPopup</code>, or <code>signInWithRedirect</code>, the email may not be verified immediately (except when using <code>GoogleAuthProvider</code>).</p>
<p>The <code>signOut</code> method can be used to reflect email verification status changes in the auth user object, as it requires the user to log in again.</p>
<h3>FYI: About Email Enumeration Protection in Firebase</h3>
<h4>Enhanced Security Against Credential Stuffing Attacks</h4>
<p>Since September 2023, Firebase has introduced Email Enumeration Protection, a feature that fortifies login functionality against traditional attacks, enhancing user security.</p>
<h4>Email Address Enumeration Attack</h4>
<p>In traditional login systems, attackers try various email addresses with random passwords. By analyzing error messages, they can discern whether an email address is registered, thus exploiting the system's vulnerabilities.</p>
<h4>How Email Enumeration Protection Works</h4>
<p>This feature ensures that all login attempts, regardless of password accuracy, return a generic "Invalid credentials" message. Consequently, attackers cannot determine email address validity solely based on error responses, mitigating enumeration attacks.</p>
<h4>Affected Methods</h4>
<p>The following methods are affected by Email Enumeration Protection:
<ul>
	<li><code>signInWithEmailAndPassword</code></li>
	<li><code>fetchSignInMethodsForEmail</code></li>
	<li><code>sendPasswordResetEmail</code></li>
</ul>
<p>When enabled, <code>fetchSignInMethodsForEmail</code> returns an empty array, and <code>sendPasswordResetEmail</code> shows no error for non-existent email addresses to avoid revealing address existence.</p>
<h4>Assumptions in this Article</h4>
<p>This article assumes Email Enumeration Protection is enabled. However, note that the Firebase Auth Emulator does not support this feature, necessitating thorough deployment and debugging for authentication functionality.</p>
<hr>
<h2 id=STORE>Firebase Firestore</h2>

Firestore is a NoSQL database that is accessible from both web clients and server-side applications.

<h3>Firestore's features</h3>
<ul>
	<li><b>NoSQL document database:</b> Firestore is a NoSQL document database, which means that it stores data in JSON-like documents. This makes it a good choice for storing unstructured data, such as user profiles, product data, and chat messages.</li>
	<li><b>Real-time updates:</b> Firestore supports real-time updates, which means that clients can be notified of changes to data as they happen. This makes it a good choice for building real-time applications, such as chat apps, social media apps, and gaming apps.</li>
	<li><b>Scalable and secure:</b> Firestore is a highly scalable and secure database that is backed by Google's infrastructure. This means that it can handle a large number of users and requests, and that your data is safe.</li>
	<li><b>Easy to use:</b> Firestore is easy to use and has a well-documented API. There are also a number of client libraries available, making it easy to develop applications for Firestore in a variety of programming languages.</li>
</ul>


<hr>
<h2 id=FUNC>Firebase Functions</h2>

<h3>Connecting External APIs in a Fictional Service</h3>
<p>In our fictional service, connecting with external APIs is crucial for functionality. However, directly connecting a client-side (web) application to external APIs presents security challenges. To overcome these hurdles, a backend service plays a vital role.</p>

<h3>Why a Backend Service is Essential:</h3>
<ul>
	<li><b>Same-Origin Policy:</b> Web browsers enforce a security measure called the same-origin policy. This restricts communication between a web page and resources from a different domain than the one that served the page. Direct client-side access to external APIs would violate this policy.</li>
	<li><b>Access Token Security:</b> External APIs often require authentication using access tokens. These tokens grant access to sensitive data or functionalities and should never be exposed to the client-side for security reasons. A backend service can securely store and manage these tokens.</li>
</ul>

<h3>Benefits of a Backend Service:</h3>
<ul>
	<li><b>Security:</b> The backend acts as a secure intermediary, shielding sensitive information like access tokens from the client-side.</li>
	<li><b>Flexibility:</b> The backend can handle API calls regardless of specific protocols (e.g., REST) or authentication mechanisms (e.g., OAuth). It can adapt to different external APIs as needed.</li>
	<li><b>Scalability:</b> The backend service can be designed to handle a high volume of API requests, ensuring performance and reliability for the client-side application.</li>
	<li><b>Periodic execution:</b>Certain functionalities may necessitate periodic processing. For instance, in this hypothetical service, fetching gold prices once a day might suffice. When scraping data, it is crucial to exercise caution to avoid overburdening the target website.</li>
</ul>

<h3>Let's look at an actual example:</h3>

まずは最もシンプルなプロクシです。

<p class="codepen" data-height="300" data-default-tab="html" data-slug-hash="VwNgpXj" data-user="satachito" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/satachito/pen/VwNgpXj">
  Firebase Functions 1</a> by Satachito (<a href="https://codepen.io/satachito">@satachito</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

これで動作しますが、2つの大きな問題があります。

まずは、この API が世界中のどこからでもアクセスできてしまうことです。
これを避ける方法はいくつかありますが、最も安全な Web 側で Firebase Authenticate を使って ユーザー情報を含む Token を作成して、
Authorization ヘッダーにセットして、Functions の中で Authorization ヘッダーから Token を取り出して verify する方法です。

Web側は以下のようなコードになります。

<pre><code>Web 側
const
app = initializeApp	(
//	Your configuration here
)
const
auth = getAuth( app )

getIdToken( auth.currentUser, true ).then(
	token => {
		fetch(
			'https://......./ticker'
		,	{ headers: { 'Authorization': 'Bearer ' + token } }
		).then(
			r => {
				if ( !r.ok ) throw new Error( r.statusText )
				return r.json()
			}
		).then(
			_ => // Do something with JavaScript Object
		).catch(
			_ => alert( _.message )
		)
	}
)
</code></pre>


<pre><code>Functions側
	( q, s ) => admin.auth().verifyIdToken( q.headers.authorization.split( 'Bearer ' )[ 1 ] ).then(
		user => fetch( 'https://example.com/ticker' ).then(
			r => {
				if ( !r.ok ) throw new Error( r.statusText )
				return r.json()
			}
		).then(
			j => send( j )
		)
	)
</code></pre>




まずはWeb からアクセスすると Same Origin Policyに引っ掛かります。
これを回避するためには onRequest の中にCORS (オリジン間リソース共有、 Cross-Origin Resource Sharing)用のコードをインプリします。

<pre><code>functions/index.js
	( q, s ) => (
		s.set( 'Access-Control-Allow-Origin', '*' )
	,	q.method === 'OPTIONS'
		?	(	s.set( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization' )
			,	s.set( 'Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE' )
			,	s.status( 200 ).end()
			)
		:	fetch( 'https://example.com/ticker' ).then(
				r => {
					if ( !r.ok ) throw new Error( r.statusText )
					return r.json()
				}
			).then(
				j => send( j )
			)
		;
	)
</code></pre>



<pre><code>
const admin				= require( 'firebase-admin' )
admin.initializeApp()

const { onSchedule }	= require( 'firebase-functions/v2/scheduler' )
exports.perDay			= onSchedule(
	'0 0 * * *'
,	_ => fetch( 'https://example.com/metals.html' ).then(
		r => {
			if ( !r.ok ) throw new Error( r.statusText )
			return r.text()
		}
	).thcn(
		html => fs.collection( 'mmc' ).doc( String( Math.floor( Date.now() / ( 1000 * 60 * 60 * 24 ) ) ) ).set(
			{ html }
		)
	)
)

</code></pre>






APIがアクセストークンを必要とする場合、ソースコード中にアクセストークンをハードコードすると、漏洩の可能性が出てきます。
例えばソースコードを公開レポジトリにおくと、そこからアクセストークンが漏洩します。
そのような場合は Google Secret Manager を使うとアクセストークンを隠蔽できます。これは Firebase の機能ではありませんが、Firebase は現在 Google に統合されているので、
Firebase からシームレスに SecreteManager を使うことができます。







<h3>Benefits of Firebase Functions:</h3>

<ul>
<li><b>Serverless architecture:</b> Firebase Functions are serverless, meaning you don't need to provision or manage servers. This makes them a cost-effective and scalable solution for running code in the cloud.</li>
<li><b>Event-driven:</b> Firebase Functions are event-driven, which means they are triggered by events such as changes to a database, file uploads, or HTTP requests. This makes them ideal for building real-time and reactive applications.</li>
<li><b>Scalable:</b> Firebase Functions automatically scale up or down based on demand, so you never have to worry about running out of capacity.</li>
<li><b>Pay-per-use:</b> You only pay for the resources that your Firebase Functions use, so you don't have to worry about upfront costs or idle resources.</li>
<li><b>Easy to use:</b> Firebase Functions are easy to develop and deploy using Node.js, JavaScript, or Python. You can also use Firebase CLI to manage your functions from the command line.</li>
<li><b>Integrated with Firebase:</b> Firebase Functions are tightly integrated with other Firebase services, such as Firestore, Realtime Database, and Authentication. This makes it easy to build and deploy cloud-native applications with Firebase.</li>
</ul>
<h3>Typical Use Cases of Firebase Functions:</h3>
<ul>
<li><b>Real-time data processing:</b> Process data in real time as it is added to a Firestore or Realtime Database.</li>
<li><b>Background tasks:</b> Perform background tasks, such as sending emails, generating reports, or processing images, without blocking the user interface.</li>
<li><b>API endpoints:</b> Create API endpoints to serve data or perform actions on behalf of your app.</li>
<li><b>Webhooks:</b> Handle webhooks from third-party services.</li>
<li><b>Authentication and authorization:</b> Implement custom authentication and authorization logic.</li>
<li><b>Triggering workflows:</b> Trigger workflows in response to events, such as user actions or changes to data.</li>
</ul>
<hr>
<h2 id=SPA_ROUTER>SPA and Router</h2>

<h3 id=SPA>SPA</h3>

<p><b>SPA (Single Page Application)</b> is a web development approach that loads a single HTML page and dynamically updates its content as the user interacts with the application. This differs from traditional multi-page web applications, which reload the entire page when the user navigates to a different section.</p>

<b>Key characteristics of SPAs include:</b>

<ul>
<li><b>Single-page structure:</b> SPAs consist of a single HTML page that serves as the foundation for the entire application. This eliminates the need for multiple page reloads, improving user experience and reducing perceived latency.</li>

<li><b>Dynamic content updates:</b> SPAs utilize JavaScript frameworks like React, Angular, or Vue.js to dynamically update the page's content without reloading the entire page. This enables seamless transitions and a more responsive user interface.</li>

<li><b>Client-side routing:</b> SPAs handle URL routing using JavaScript, intercepting user navigation requests and updating the application's state accordingly. This allows for smooth transitions between different sections of the application without the need for server-side interactions.</li>
</ul>

<b>Benefits of using SPAs:</b>

<ul>
<li><b>Enhanced user experience:</b> SPAs provide a more fluid and responsive user experience, as content updates occur without page reloads. This can lead to increased engagement and satisfaction among users.</li>

<li><b>Improved performance:</b> SPAs can potentially improve performance by reducing the amount of data transferred between the client and server. This is because only the necessary content is loaded for each view, rather than reloading the entire page.</li>

<li><b>Easier maintenance:</b> SPAs can be easier to maintain and update, as the entire application's code is contained within a single-page structure. This can streamline development and deployment processes.</li>
</ul>

<p><b>In the context of the fictional services mentioned above, for example:</b></p>

<ul>
<li>Stocks would be assigned the URL <code>/stock</code></li>
<li>FX would be assigned the URL <code>/fx</code></li>
<li>Metals would be assigned the URL <code>/metal</code></li>
<li>Crypto would be assigned the URL <code>/crypto</code></li>
<li>However, no actual content would be placed at these URLs.</li>
</ul>

<p><b>Normally, a web server would return a 404 (Not Found) error in this case. However, by configuring the server to rewrite requests, it can be instructed to return <code>/index.html</code> instead when a 404 occurs.</b></p>

<p><b><code>/index.html</code> would then determine what to display based on the URL that was called.</b></p>

<p><b>Therefore, SPAs are not just a programming problem; they also require careful consideration of server configuration.</b></p>

<p><b>Here is a more detailed explanation:</b></p>

<ul>
	<li>In a traditional web application, each URL is associated with a specific file or resource on the server. When a user visits a URL, the server sends the corresponding file or resource to the user's browser.</li>
	<li>In an SPA, there is only one HTML page (<code>/index.html</code>). This page contains all of the JavaScript code that is needed to run the application.</li>
	<li>When a user visits a URL, the server returns the <code>/index.html</code> page to the user's browser. The JavaScript code in <code>/index.html</code> then takes over and dynamically generates the content of the page based on the URL that was visited.</li>

	<li>In order for this to work on Firebase Hosting, you would specify rewrite rules into firebase.json fire in the root directory of your project.</li>
</ul>

<pre><code>
{	...
	"hosting": {
		...
		"rewrites": [
			{ "source": "**", "destination": "/index.html" }
		]
	}
}
</code></pre>

<ul>
	<li>This can be also done using a variety of methods, such as Apache's mod_rewrite or Nginx's rewrite module.</li>
	<li>Once the server is configured to rewrite requests, the <code>/index.html</code> page can use JavaScript to determine what to display based on the URL that was visited. For example, if the user visits <code>/stock</code>, the <code>/index.html</code> page could display a stock ticker. If the user visits <code>/fx</code>, the <code>/index.html</code> page could display a currency exchange rate chart.</li>
	<li>SPAs have a number of advantages over traditional web applications. They can provide a more responsive and user-friendly experience, and they can be easier to develop and maintain. However, they also require more careful consideration of server configuration.</li>
</ul>



<h3 id=ROUTER>Routers: The Backbone of SPA Navigation</h3>

<p>Routers play a crucial role in SPAs, enabling users to navigate between different parts of the application without reloading the entire page. They are responsible for interpreting the URL, identifying the appropriate route, and rendering the corresponding content.</p>

<h4>Hash-Based Routing: The Traditional Approach</h4>
<p>Hash-based routing, also known as fragment-based routing, utilizes the hash fragment (#) in the URL to determine the route. For instance, the URL <code>https://example.com/#/stock</code> would indicate the stock ticker route.</p>

<h5>Advantages:</h5>
<ul>
<li>Simple implementation</li>
</ul>

<h5>Disadvantages:</h5>
<ul>
<li>Hash fragment is not part of the actual URL, affecting SEO and bookmarking</li>
<li>Some search engines may not index hash-based URLs effectively</li>
</ul>

<h4>History API-Based Routing: The Modern Approach</h4>
<p>History API-based routing leverages the browser's history API to manage the URL and maintain the user's navigation history. It provides a cleaner and more SEO-friendly approach to routing in SPAs.</p>

<h5>Advantages:</h5>
<ul>
	<li>Clean URLs that appear in the address bar</li>
	<li>Improved SEO and bookmarking capabilities</li>
	<li>Supports browser history features like back and forward buttons</li>
</ul>

<h5>Disadvantages:</h5>
<ul>
	<li>Slightly more complex implementation compared to hash-based routing</li>
</ul>

<h4>Sample code(Vanilla JS)</h4>

<p>While frameworks like Vue and React offer convenient routing solutions, Vanilla JavaScript routing provides a unique set of advantages, including enhanced flexibility, extensibility, and a deeper understanding of routing concepts.</p>

<h5>Working sample</h5>
<p><a href=https://vanillarouterdemo.web.app/ target=_blank>https://vanillarouterdemo.web.app/</a></p>
The browser history functionality is available for use there.

<h5>Source code(CodePen)</h5>
<p class="codepen" data-height="300" data-default-tab="html" data-slug-hash="LYpEXPY" data-user="satachito" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/satachito/pen/LYpEXPY">
  Router</a> by Satachito (<a href="https://codepen.io/satachito">@satachito</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

<h5>Vanilla JavaScript Routing: A Deeper Dive</h5>
<p>Unlike framework-based routing, Vanilla JavaScript routing involves crafting custom JavaScript code to manage routing logic and DOM updates. This approach offers greater control over how routing is implemented, allowing for customization to suit specific needs.</p>


<h5>Key Benefits of Vanilla JavaScript Routing:</h5>
<ul>
<li><b>Enhanced Flexibility:</b> Vanilla JavaScript routing grants complete control over routing implementation, enabling tailored solutions for unique requirements.</li>
<li><b>Superior Extensibility:</b> Routing functionality can be seamlessly extended to support advanced features like nested routes and dynamic route parameters.</li>
<li><b>Deeper Routing Understanding:</b> By writing your own router, you gain a profound understanding of routing mechanisms and their interaction with the DOM.</li>
</ul>


<h5>Leveraging Templates and Iframes:</h5>
Vanilla JavaScript routing extends beyond component-based routing, enabling content rendering through templates or iframes:
<ul>
<li><b>Template-based Routing:</b> Templates or templating techniques can be employed to directly render content into the DOM.</li>
<li><b>Iframe-based Routing:</b> Content can be loaded into iframes, allowing for embedding external pages or applications within the SPA.</li>
</ul>


<h5>Web Components: A Complementary Approach</h5>
<p>Web Components serve as an alternative to framework-based components within Vanilla JavaScript routing. They offer reusable custom HTML elements with encapsulated behavior and styling, providing modularity and reusability.</p>


<hr>
<p>Thank you for reading this article. I hope this article will be helpful for those who want to start their own membership-based online service using Firebase!</p>
<!-- And if possible, would you be willing to make a small donation? Your donation will help me create more helpful content in the future.</p> -->


</body>

</html>

