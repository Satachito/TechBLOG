<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Start a membership service with Firebase</title>

<style>
body {
;	max-width			: 640px
}
pre {
;	background-color	: black
;	padding				: 12px
;	overflow			: scroll
;	tab-size			: 4
}
code {
;	color				: blue
}
pre > code {
;	color				: yellow
}
img {
;	max-width			: 320px
}
</style>
</head>

<body>



<h2>Start a membership online service with Firebase</h2>


<p>In recent years, the development of cloud services has created an environment where individuals can easily start their own membership-based online services.</p>

<p>In particular, using a Backend as a Service (BaaS) like Firebase allows developers to greatly simplify the complex process of building a backend. </p>

<p>Firebase provides many of the features needed to build an online service, such as authentication, database, file storage, and serverless functions, allowing developers to focus on the core functionality of their service.</p>

<p>Firebase also automatically scales with service growth, which can significantly reduce operational costs.</p>

<p>In this article, I will explain the specific steps for starting a membership-based online service as an individual using Firebase, while creating a fictitious service with slightly relaxed security as an example.</p>

<hr>

<h3>Fictitious service specification</h3>

<img src=HOME.png alt="Home image">

<h4>Concept:</h4>
<ul>
<li>Type: Investment information portal</li>
<li>Revenue model: Advertising revenue and newsletter subscriptions</li>
</ul>

<h4>Functional requirements:</h4>
<ul>
	<li>User registration and login</li>
	<li>Content management</li>
	<li>Payment processing</li>
	<li>External API integration:
		<ul>
			<li>Various market data APIs</li>
			<li>Scraping</li>
		</ul>
	</li>
	<li>Single-page application (SPA)</li>
</ul>

<h4>Security requirements:</h4>
<ul>
	<li>Only email addresses stored</li>
	<li>No personal information collected</li>
</ul>

<h4>Technical requirements:</h4>
<ul>
	<li>Frontend: Vanilla JS</li>
	<li>Backend: Firebase</li>
	<li>Database: Firebase Firestore</li>
	<li>Authentication: Firebase Authentication</li>
	<li>Payment processing: Stripe</li>
	<li>External APIs:
		<ul>
			<li>Cryptocurrency exchanges</li>
			<li>Precios metals dealers</li>
		</ul>
	</li>
</ul>

<p>The source code is available on <a href=https://github.com/Satachito/exp-fb target=_blank>GitHub</a> and service is available at <a href=https://exp-fb-c223c.web.app/ target=_blank>https://exp-fb-c223c.web.app/</a>.

<hr>

<h3>Table of contents:</h3>
<ul>
	<li><a href=#AUTH>Firebase Authentication</a></li>
	<li><a href=#FUNC>Firebase Firestore</a></li>
	<li><a href=#FUNC>Firebase Functions</a></li>
	<li><a href=#SPA_ROUTER>SPA and Router</a>
		<ul>
			<li><a href=#SPA>SPA</a></li>
			<li><a href=#ROUTER>ROUTER</a></li>
		</ul>
	</li>
</ul>

<hr>
<h2 id=FUNC>Firebase Firestore</h2>

Firestore is a NoSQL database that is accessible from both web clients and server-side applications.

<h3>Firestore's features</h3>
<ul>
	<li><b>NoSQL document database:</b> Firestore is a NoSQL document database, which means that it stores data in JSON-like documents. This makes it a good choice for storing unstructured data, such as user profiles, product data, and chat messages.</li>
	<li><b>Real-time updates:</b> Firestore supports real-time updates, which means that clients can be notified of changes to data as they happen. This makes it a good choice for building real-time applications, such as chat apps, social media apps, and gaming apps.</li>
	<li><b>Scalable and secure:</b> Firestore is a highly scalable and secure database that is backed by Google's infrastructure. This means that it can handle a large number of users and requests, and that your data is safe.</li>
	<li><b>Easy to use:</b> Firestore is easy to use and has a well-documented API. There are also a number of client libraries available, making it easy to develop applications for Firestore in a variety of programming languages.</li>
</ul>


<hr>
<h2 id=FUNC>Firebase Functions</h2>

<h3>Connecting External APIs in a Fictional Service</h3>
<p>In our fictional service, connecting with external APIs is crucial for functionality. However, directly connecting a client-side (web) application to external APIs presents security challenges. To overcome these hurdles, a backend service plays a vital role.</p>

<h3>Why a Backend Service is Essential:</h3>
<ul>
	<li><b>Same-Origin Policy:</b> Web browsers enforce a security measure called the same-origin policy. This restricts communication between a web page and resources from a different domain than the one that served the page. Direct client-side access to external APIs would violate this policy.</li>
	<li><b>Access Token Security:</b> External APIs often require authentication using access tokens. These tokens grant access to sensitive data or functionalities and should never be exposed to the client-side for security reasons. A backend service can securely store and manage these tokens.</li>
</ul>

<h3>Benefits of a Backend Service:</h3>
<ul>
	<li><b>Security:</b> The backend acts as a secure intermediary, shielding sensitive information like access tokens from the client-side.</li>
	<li><b>Flexibility:</b> The backend can handle API calls regardless of specific protocols (e.g., REST) or authentication mechanisms (e.g., OAuth). It can adapt to different external APIs as needed.</li>
	<li><b>Scalability:</b> The backend service can be designed to handle a high volume of API requests, ensuring performance and reliability for the client-side application.</li>
	<li><b>Periodic execution:</b>Certain functionalities may necessitate periodic processing. For instance, in this hypothetical service, fetching gold prices once a day might suffice. When scraping data, it is crucial to exercise caution to avoid overburdening the target website.</li>
</ul>

<h3>Let's look at an actual example:<h3>

<pre><code>functions/index.js
const admin = require( 'firebase-admin' )	
admin.initializeApp()


const { onRequest	} = require( 'firebase-functions/v2/https'		)

exports.ticker = onRequest(
	( q, s ) => fetch( 'https://example.com/ticker' ).then(
		r => {
			if ( !r.ok ) throw new Error( r.statusText )
			return r.json()
		}
	).then(
		j => send( j )
	)
)


const { onSchedule	} = require( 'firebase-functions/v2/scheduler'	)

exports.perDay	= onSchedule(
	'0 0 * * *'
,	_ => FetchTEXT( 'https://example.com/metals' ).then(
		_ => fs.collection( 'mmc' ).doc( String( Math.floor( Date.now() / ( 1000 * 60 * 60 * 24 ) ) ) ).set(
			{ html: _ }
		)
	).catch(
		error
	)
)

</code></pre>






APIがアクセストークンを必要とする場合、ソースコード中にアクセストークンをハードコードすると、漏洩の可能性が出てきます。
例えばソースコードを公開レポジトリにおくと、そこからアクセストークンが漏洩します。
そのような場合は Google Secret Manager を使うとアクセストークンを隠蔽できます。これは Firebase の機能ではありませんが、Firebase は現在 Google に統合されているので、
Firebase からシームレスに SecreteManager を使うことができます。







<h3>Benefits of Firebase Functions:</h3>

<ul>
<li><b>Serverless architecture:</b> Firebase Functions are serverless, meaning you don't need to provision or manage servers. This makes them a cost-effective and scalable solution for running code in the cloud.</li>
<li><b>Event-driven:</b> Firebase Functions are event-driven, which means they are triggered by events such as changes to a database, file uploads, or HTTP requests. This makes them ideal for building real-time and reactive applications.</li>
<li><b>Scalable:</b> Firebase Functions automatically scale up or down based on demand, so you never have to worry about running out of capacity.</li>
<li><b>Pay-per-use:</b> You only pay for the resources that your Firebase Functions use, so you don't have to worry about upfront costs or idle resources.</li>
<li><b>Easy to use:</b> Firebase Functions are easy to develop and deploy using Node.js, JavaScript, or Python. You can also use Firebase CLI to manage your functions from the command line.</li>
<li><b>Integrated with Firebase:</b> Firebase Functions are tightly integrated with other Firebase services, such as Firestore, Realtime Database, and Authentication. This makes it easy to build and deploy cloud-native applications with Firebase.</li>
</ul>
<h3>Typical Use Cases of Firebase Functions:</h3>
<ul>
<li><b>Real-time data processing:</b> Process data in real time as it is added to a Firestore or Realtime Database.</li>
<li><b>Background tasks:</b> Perform background tasks, such as sending emails, generating reports, or processing images, without blocking the user interface.</li>
<li><b>API endpoints:</b> Create API endpoints to serve data or perform actions on behalf of your app.</li>
<li><b>Webhooks:</b> Handle webhooks from third-party services.</li>
<li><b>Authentication and authorization:</b> Implement custom authentication and authorization logic.</li>
<li><b>Triggering workflows:</b> Trigger workflows in response to events, such as user actions or changes to data.</li>
</ul>













<h3></h3>
<ul>
	<li><b></b></li>
	<li><b></b></li>
</ul>

<hr>
<h2 id=AUTH>Firebase Authentication</h2>

<p>Firebase is a powerful platform that streamlines app development. However, it is currently in a state of flux, undergoing frequent version updates. The transition to v9, in particular, introduced a significant change with the introduction of the Modular API, which features a syntax that is vastly different from the traditional API.</p>

<h4>Migrating to the Modular API</h4>
<p>While the Modular API enables more flexible and efficient development, it breaks compatibility with legacy code. The Firebase team provides compat versions to maintain compatibility with past code, but the migration to the Modular API is recommended for the future.</p>

<h4>Firebase-UI and the Modular API</h4>
<p>Firebase includes Firebase-UI, an open-source UI library that simplifies the implementation of login functionality and more. However, Firebase-UI does not currently support the Modular API, and the migration process is expected to be time-consuming.</p>

<h4>Adapting to the Future</h4>
<p>Firebase will continue to evolve, and even more significant changes may be introduced in the future.</p>

<h4>Implementing a Robust Login Solution</h4>
<p>Considering this landscape, directly utilizing Firebase's features to implement login functionality emerges as the most viable option from a long-term perspective.</p>

<img src=SS1.png alt="Login dialog image">
<img src=SS2.png alt="Login dialog image">
<img src=SS3.png alt="Login dialog image">
<img src=SS4.png alt="Login dialog image">

<p>By embracing the latest developments in Firebase and implementing login functionality directly, developers can ensure the longevity and adaptability of their applications.</p>

Let's take a look at the code, the HTML and CSS are shown on CodePen. Javascript follows separately because firebase does not work in CodePen.
A working version is available at <a href=https://tech.sat.tokyo/Contents/FirebaseAuth.html target=_blank>https://tech.sat.tokyo/Contents/FirebaseAuth.html</a>

<p class="codepen" data-height="300" data-default-tab="html" data-slug-hash="RwOyxzr" data-user="satachito" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/satachito/pen/RwOyxzr">
  Firebase AUTH</a> by Satachito (<a href="https://codepen.io/satachito">@satachito</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>


<pre><code>
import {
	initializeApp
} from "https://www.gstatic.com/firebasejs/10.10.0/firebase-app.js"
const
app = initializeApp(
//	YOUR CONFIG HERE
)

import {
	getAnalytics
} from 'https://www.gstatic.com/firebasejs/10.10.0/firebase-analytics.js'
const
analytics = getAnalytics( app )

import {
	getAuth
,	onAuthStateChanged
,	signInWithEmailAndPassword
,	signInWithPopup
,	signInWithRedirect
,	sendPasswordResetEmail
,	sendEmailVerification
,	createUserWithEmailAndPassword
,	GoogleAuthProvider
,	FacebookAuthProvider
,	GithubAuthProvider
,	signOut
,	deleteUser
} from 'https://www.gstatic.com/firebasejs/10.10.0/firebase-auth.js'
const
auth = getAuth( app )

const
E = _ => document.getElementById( _ )

E( 'GOOGLE_LOGIN_B'		).onclick = () => signInWithRedirect( auth, new GoogleAuthProvider		() )
E( 'FACEBOOK_LOGIN_B'	).onclick = () => signInWithRedirect( auth, new FacebookAuthProvider	() )
E( 'GITHUB_LOGIN_B'		).onclick = () => signInWithRedirect( auth, new GithubAuthProvider		() )

E( 'EMAIL_LOGIN_B'		).onclick = () => signInWithEmailAndPassword		( auth, E( 'EMAIL_I' ).value, E( 'PASSWORD_I' ).value	).catch( er => alert( er.message ) )
E( 'CREATE_ACCOUNT_B'	).onclick = () => createUserWithEmailAndPassword	( auth, E( 'EMAIL_I' ).value, E( 'PASSWORD_I' ).value	).catch( er => alert( er.message ) )

E( 'RESET_PASSWORD_B'	).onclick = () => sendPasswordResetEmail( auth, E( 'EMAIL_I' ).value ).then( () => alert( 'Password reset mail sent' ) ).catch( er => alert( er.message ) )

E( 'LOGOUT_B'			).onclick = () => signOut( auth )
E( 'DELETE_ACCOUNT_B'	).onclick = () => deleteUser( auth.currentUser )

onAuthStateChanged(
	auth
,	user => (
		E( 'LOGIN_D' ).close()
	,	E( 'MY_D' ).close()
	,	user
		?	(	user.emailVerified || (
					sendEmailVerification( user ).then( () => alert( 'A confirmation email has been sent to the address provided. Kindly click the link within the email to confirm delivery.' ) )
				,	signOut( auth )
				)
			,	E( 'USER_B' ).textContent	= 'MyPage: ' + user.email
			,	E( 'USER_B' ).onclick		= () => E( 'MY_D' ).showModal()
			)
		:	(	E( 'USER_B' ).textContent	= 'Sign in/up'
			,	E( 'USER_B' ).onclick		= () => E( 'LOGIN_D' ).showModal()
			)
	)
)
</code></pre>

<p><b>(A):</b>If a user creates an account using <code>createUserWithEmailAndPassword</code>, <code>signInWithPopup</code> or <code>signInWithRedirect</code>, the user's email may not yet be verified.
(The email address is automatically verified only when using <code>GoogleAuthProvider</code>)</p>
<p>The user object in auth will not reflect that the email has been verified until the user logs in again, so <code>signOut</code> is one way to do it here.</p>




<h3>FYI: About Email Enumeration Protection in Firebase</h3>

<h4>Enhanced Security Against Credential Stuffing Attacks</h4>

<p>Since September 2023, Firebase has introduced the Email Enumeration Protection feature for its login functionality. This feature, also known as Email Address Enumeration Defense, neutralizes traditional attack methods and enhances user security.

<h4>What is Email Address Enumeration Attack?</h4>

<p>In traditional login systems, attackers attempt to log in to a target service with various email addresses and random passwords. If the error message "Email address is not registered" appears, the attacker can determine that the address is not registered. On the other hand, if the message "Incorrect password" is displayed, the attacker can confirm that the address is registered.</p>

<h4>How Email Enumeration Protection Works</h4>

<p>When the Email Enumeration Protection feature is enabled, all login attempts, regardless of the password, will result in the error message "Invalid credentials". This prevents attackers from determining whether an email address is registered, effectively thwarting email address enumeration attacks.</p>

<h4>Affected Methods</h4>

<p>The following methods are affected by enabling Email Enumeration Protection:

<ul>
	<li><code>signInWithEmailAndPassword</code></li>
	<li><code>fetchSignInMethodsForEmail</code></li>
	<li><code>sendPasswordResetEmail</code></li>
</ul>
<p>The <code>fetchSignInMethodsForEmail</code> function returns empty array.</p>
<p>The <code>sendPasswordResetEmail</code> is a function that sends a password reset email to a user. When this feature is enabled, no error will occur even for non-existent email addresses. This is because sending an email to a non-existent address is pointless, and the error message could reveal the existence of the address.</p>


<h4>Assumptions in this Article</h4>

<p>This article assumes that the Email Enumeration Protection feature is enabled.</p>
<p>However, the Firebase Auth Emulator does not have this feature, so you need to deploy and debug the authentication functionality thoroughly.</p>


<hr>
<h2 id=SPA_ROUTER>SPA and Router</h2>

<h3 id=SPA>SPA</h3>

<p><b>SPA (Single Page Application)</b> is a web development approach that loads a single HTML page and dynamically updates its content as the user interacts with the application. This differs from traditional multi-page web applications, which reload the entire page when the user navigates to a different section.</p>

<b>Key characteristics of SPAs include:</b>

<ul>
<li><b>Single-page structure:</b> SPAs consist of a single HTML page that serves as the foundation for the entire application. This eliminates the need for multiple page reloads, improving user experience and reducing perceived latency.</li>

<li><b>Dynamic content updates:</b> SPAs utilize JavaScript frameworks like React, Angular, or Vue.js to dynamically update the page's content without reloading the entire page. This enables seamless transitions and a more responsive user interface.</li>

<li><b>Client-side routing:</b> SPAs handle URL routing using JavaScript, intercepting user navigation requests and updating the application's state accordingly. This allows for smooth transitions between different sections of the application without the need for server-side interactions.</li>
</ul>

<b>Benefits of using SPAs:</b>

<ul>
<li><b>Enhanced user experience:</b> SPAs provide a more fluid and responsive user experience, as content updates occur without page reloads. This can lead to increased engagement and satisfaction among users.</li>

<li><b>Improved performance:</b> SPAs can potentially improve performance by reducing the amount of data transferred between the client and server. This is because only the necessary content is loaded for each view, rather than reloading the entire page.</li>

<li><b>Easier maintenance:</b> SPAs can be easier to maintain and update, as the entire application's code is contained within a single-page structure. This can streamline development and deployment processes.</li>
</ul>

<p><b>In the context of the fictional services mentioned above, for example:</b></p>

<ul>
<li>Stocks would be assigned the URL <code>/stock</code></li>
<li>FX would be assigned the URL <code>/fx</code></li>
<li>Metals would be assigned the URL <code>/metal</code></li>
<li>Crypto would be assigned the URL <code>/crypto</code></li>
<li>However, no actual content would be placed at these URLs.</li>
</ul>

<p><b>Normally, a web server would return a 404 (Not Found) error in this case. However, by configuring the server to rewrite requests, it can be instructed to return <code>/index.html</code> instead when a 404 occurs.</b></p>

<p><b><code>/index.html</code> would then determine what to display based on the URL that was called.</b></p>

<p><b>Therefore, SPAs are not just a programming problem; they also require careful consideration of server configuration.</b></p>

<p><b>Here is a more detailed explanation:</b></p>

<ul>
	<li>In a traditional web application, each URL is associated with a specific file or resource on the server. When a user visits a URL, the server sends the corresponding file or resource to the user's browser.</li>
	<li>In an SPA, there is only one HTML page (<code>/index.html</code>). This page contains all of the JavaScript code that is needed to run the application.</li>
	<li>When a user visits a URL, the server returns the <code>/index.html</code> page to the user's browser. The JavaScript code in <code>/index.html</code> then takes over and dynamically generates the content of the page based on the URL that was visited.</li>

	<li>In order for this to work on Firebase Hosting, you would specify rewrite rules into firebase.json fire in the root directory of your project.</li>
</ul>

<pre><code>
{	...
	"hosting": {
		...
		"rewrites": [
			{ "source": "**", "destination": "/index.html" }
		]
	}
}
</code></pre>

<ul>
	<li>This can be also done using a variety of methods, such as Apache's mod_rewrite or Nginx's rewrite module.</li>
	<li>Once the server is configured to rewrite requests, the <code>/index.html</code> page can use JavaScript to determine what to display based on the URL that was visited. For example, if the user visits <code>/stock</code>, the <code>/index.html</code> page could display a stock ticker. If the user visits <code>/fx</code>, the <code>/index.html</code> page could display a currency exchange rate chart.</li>
	<li>SPAs have a number of advantages over traditional web applications. They can provide a more responsive and user-friendly experience, and they can be easier to develop and maintain. However, they also require more careful consideration of server configuration.</li>
</ul>



<h3 id=ROUTER>Routers: The Backbone of SPA Navigation</h3>

<p>Routers play a crucial role in SPAs, enabling users to navigate between different parts of the application without reloading the entire page. They are responsible for interpreting the URL, identifying the appropriate route, and rendering the corresponding content.</p>

<h4>Hash-Based Routing: The Traditional Approach</h4>
<p>Hash-based routing, also known as fragment-based routing, utilizes the hash fragment (#) in the URL to determine the route. For instance, the URL <code>https://example.com/#/stock</code> would indicate the stock ticker route.</p>

<h5>Advantages:</h5>
<ul>
<li>Simple implementation</li>
</ul>

<h5>Disadvantages:</h5>
<ul>
<li>Hash fragment is not part of the actual URL, affecting SEO and bookmarking</li>
<li>Some search engines may not index hash-based URLs effectively</li>
</ul>

<h4>History API-Based Routing: The Modern Approach</h4>
<p>History API-based routing leverages the browser's history API to manage the URL and maintain the user's navigation history. It provides a cleaner and more SEO-friendly approach to routing in SPAs.</p>

<h5>Advantages:</h5>
<ul>
	<li>Clean URLs that appear in the address bar</li>
	<li>Improved SEO and bookmarking capabilities</li>
	<li>Supports browser history features like back and forward buttons</li>
</ul>

<h5>Disadvantages:</h5>
<ul>
	<li>Slightly more complex implementation compared to hash-based routing</li>
</ul>

<h4>Sample code(Vanilla JS)</h4>

<p>While frameworks like Vue and React offer convenient routing solutions, Vanilla JavaScript routing provides a unique set of advantages, including enhanced flexibility, extensibility, and a deeper understanding of routing concepts.</p>

<h5>Working sample</h5>
<p><a href=https://vanillarouterdemo.web.app/ target=_blank>https://vanillarouterdemo.web.app/</a></p>
The browser history functionality is available for use there.

<h5>Source code(CodePen)</h5>
<p class="codepen" data-height="300" data-default-tab="html" data-slug-hash="LYpEXPY" data-user="satachito" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/satachito/pen/LYpEXPY">
  Router</a> by Satachito (<a href="https://codepen.io/satachito">@satachito</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

<h5>Vanilla JavaScript Routing: A Deeper Dive</h5>
<p>Unlike framework-based routing, Vanilla JavaScript routing involves crafting custom JavaScript code to manage routing logic and DOM updates. This approach offers greater control over how routing is implemented, allowing for customization to suit specific needs.</p>


<h5>Key Benefits of Vanilla JavaScript Routing:</h5>
<ul>
<li><b>Enhanced Flexibility:</b> Vanilla JavaScript routing grants complete control over routing implementation, enabling tailored solutions for unique requirements.</li>
<li><b>Superior Extensibility:</b> Routing functionality can be seamlessly extended to support advanced features like nested routes and dynamic route parameters.</li>
<li><b>Deeper Routing Understanding:</b> By writing your own router, you gain a profound understanding of routing mechanisms and their interaction with the DOM.</li>
</ul>


<h5>Leveraging Templates and Iframes:</h5>
Vanilla JavaScript routing extends beyond component-based routing, enabling content rendering through templates or iframes:
<ul>
<li><b>Template-based Routing:</b> Templates or templating techniques can be employed to directly render content into the DOM.</li>
<li><b>Iframe-based Routing:</b> Content can be loaded into iframes, allowing for embedding external pages or applications within the SPA.</li>
</ul>


<h5>Web Components: A Complementary Approach</h5>
<p>Web Components serve as an alternative to framework-based components within Vanilla JavaScript routing. They offer reusable custom HTML elements with encapsulated behavior and styling, providing modularity and reusability.</p>


<hr>
<p>Thank you for reading this article. I hope this article will be helpful for those who want to start their own membership-based online service using Firebase!</p>
<!-- And if possible, would you be willing to make a small donation? Your donation will help me create more helpful content in the future.</p> -->


</body>

</html>

